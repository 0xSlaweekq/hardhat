# Описание метода реинвестирования

# Первый вариант:

Вводим такое понятие как сезон - период от реинвеста до следующего реинвеста.
На каждой транзакции юзера делаем пересчет его текущей доли владения длп токена (на основании суммы и времени владения). В случае, если пользователь не был активен несколько сезонов подряд, то сложность пересчета увеличивается в n раз (где n - количество неактивных сезонов)

Плюсы данной реализации:

- Безопасность - извне повлиять на получение прибыли будет сложно, если зайдет кит перед реинвестом, он не сможет забрать все накопления(как реализовано сейчас)
- точные расчеты по каждому юзеру в частности, без нарушения хронологии его действий
- без лишних просчетов и подписей со стороны бэка, тем самым простота в интеграции

Точные цифры математики и формулы еще нужно немного докрутить, но тут есть сразу пару нюансов:

- если юзер на протяжении, к примеру, 100 или 1000 сезонов, а того и более(вложил деньги на пару лет) не будет предпринимать никаких действий в пуле, то после этого, при первой его транзакции, сперва нужно будет просчитать все его балансы за каждый из сезонов, что может быть слишком дорого для юзера в таком случае(но по завершении аналитики и формул для расчета, можно будет смодулировать такую транзакцию искусственно, чтобы видеть примерные значения затраченного газа) или вовсе транзакция будет ревертиться по газвару, тогда ее нужно будет делить по определенному количеству сезонов, но снова же, сколько транзакций это будет и какая их стоимость остается открытым вопросом

Во время депозита необходимо общую и по каждому юзеру мапить информацию, например, как я вижу структуру:
totalLP - общее количество лп
totalWeight - общий вес

started - булевая начала действия пула

ReinvestInfo
season: текущий сезон
startTime: время начала сезона
reinvestTime: время, когда произлшел реинвест(при переходе на новый сезон, тут ставится, а для нового это уже будет startTime)
startTotalWeight: начальное значение веса в сезоне
endTotalWeight: конечный вес(по аналогии с reinvestTime)
totalFarmed: общий заработок за все реинвесты(суммируется)
totalLP: общее лп на момент закрытия сезона

season - какой текущий сезон
reinvestTime - время реинвестирования
lastUpdateTime - последнее время обновления данных(обновляется каждую транзакцию)
currentFarmed сколько сейчас заработано(конкретно в текущем сезоне)

UserInfo - информация по юзеру
amountLP: сколько вложено юзером
weight: вес юзера
lastTotalWeight: последний общий вес
season: последний сезон, в каком юзер делал какую-либо транзакцию

## Сам процесс:

1. Человек выбрал в какой пул инвестировать, указал сумму и нажал кнопку депозит
2. В функции мы записали struct UserInfo, в нем уже записываем amountLP, weight, lastTotalWeight и season
3. Когда человек захочет исполнить транзакцию в определенный пул, сперва сверяем в какой пул он ее отправляет (UserInfo -> poolType)
4. просчитываем срок вложения(время прошедшее от предыдущего изменения глобального стейта, до текщего) dTime = time - lastUpdateTime
5. обновляем общий вес, при условии if (dTime != 0 && totalLP != 0) totalWeight += dTime / totalLP;
6. Далее сделать просчет нового веса юзера на основе изначальных данных, сколько человек вложил и какой вес имеет (чтобы узнать срок инвестирования)
7. Обновляем его баланс и totalLP
   let newAmountLP = UserInfo[id].amountLP;
   if (type == 'deposit') {
   newAmountLP += amountLP;
   totalLP += amountLP;
   }
   if (type == 'withdraw') {
   newAmountLP -= amountLP;
   totalLP -= amountLP;
   }
8. далее сверяем сезон юзера с текущим сезоном и дальше идет условие:
   а: если сезон совпадает:
   - Обновляем общий вес и лп
   - Записываем полученные результат в UserInfo
     UserInfo[id] = {
     amountLP: newAmountLP,
     weight,
     lastTotalWeight: totalWeight,
     season
     }
     б: если сезон не совпадает:
   - обращаемся к массиву данных по каждому из сезонов в цикле, начиная с UserInfo[id].season до ReinvestInfo.length, но при этом появляется новое условие poolInfo = ReinvestInfo[i]
     а: если i+1 не равен текущему сезону:
     - считаем вес сезона
     - считаем дельту времени, что он пробыл в пуле с момента его последней транзакции до момента закрытия сезона(реинвеста)
       dTimeSeason = poolInfo.reinvestTime - poolInfo.startTime
     - просчитываем процент его доли percent = weightSeason / dTimeSeason;
     - просчитываем, сколько доступно для клейма из доходной лп availibleToClaim = percent \* poolInfo.totalFarmed;
     - просчитываем вес юзера в последнем сезоне, в котором он участвовал + фиксируем новый lastTotalWeight (обновление каждый пройденный цикл для конкретного сезона)
     - записываем новую информацию о юзере, прибавляя к его amountLP заработанные средства
       UserInfo[id] = {
       amountLP: UserInfo[id].amountLP + availibleToClaim,
       weight: weightSeason,
       lastTotalWeight: poolInfo.endTotalWeight,
       season
       }
     - обновляем значение тотал лп totalLP += availibleToClaim;
     - повтор, и так до тех пор, пока цикл не пройдет по всей длине массива ReinvestInfo, как только i+1 станет равным текущему сезону, идем по else
       б: i+1 равен текущему сезону
     - считаем текущий вес пользователя(все его предыдущие веса и вложения уже пересчитаны и просуммированы как надо)
     - определяем, делает человек депозит или вывод и обновляем на основе этих данных UserInfo(прибавляем текущий value или вычитаем из его amountLP)4
     - Записываем полученные результат в UserInfo
       if (type == 'deposit') {
       UserInfo[id] = {
       amountLP: UserInfo[id].amountLP + amountLP,
       weight: currentWeight,
       lastTotalWeight: totalWeight,
       season
       };
       }
       if (type == 'withdraw') {
       UserInfo[id] = {
       amountLP: UserInfo[id].amountLP - amountLP,
       weight: currentWeight,
       lastTotalWeight: totalWeight,
       season
       };
       }
9. обновляем lastUpdateTime

## Во время реинвеста логика примерна такая:

1. фиксируем текущее время time
2. считаем текущий заработок в пуле, делая сам реинвест, получаю значение уже чистой лп, которая прибавилась в пул currentFarmed
3. обновляем totalFarmed += currentFarmed(сквозной просчет)
4. обновляем информацию в текущем пуле ReinvestInfo, а именно:
   ReinvestInfo[season] = {
   season: season(текущий сезон),
   startTime: reinvestTime(это время прошлого реинвеста),
   reinvestTime: time(текущее время),
   startTotalWeight: ReinvestInfo[season].startTotalWeightЖReinvestInfo(не трогаем, это значение уже инициализировано),
   endTotalWeight: totalWeight(текущий вес),
   totalFarmed: currentFarmed(сколько заработанно конкретно в этом сезоне),
   totalLP: totalLP(обновляем сколько лп на момент реинвеста)
   };
5. обновляем reinvestTime = time(текущее время)
6. обновляем сезон season++ startTotalWeight = totalWeight(это значение будет использоваться для установки в новый сезон)
7. инициализируем данные для нового сезона:
   ReinvestInfo[season] = {
   season: season,
   startTime: reinvestTime(это время уже текущего реинвеста),
   reinvestTime: 0,
   startTotalWeight: totalWeight(это значение используется для установки начального в новом сезоне),
   endTotalWeight: 0,
   totalFarmed: 0,
   totalLP: 0
   };

# Второй вариант:

Логику первого варианта частично развернуть на бэке. В контракте оставить маппы и структуры по записыванию информации как общей, так и отдельного юзера, но в момент, когда сезоны не будут совпадать, ретернить транзакцию со всеми необходимыми данными на бэк. Если бэк будет получать не успешное выполнение транзакции, а массив данных, то он начнет просчет на основе полученных данных. Затем, оценит стоимость транзакции обновления баланса юзера и общего стейта - вычесть данную комиссию +10%(от самой комиссии) от уже полного amountLP юзера и отправить транзакцию на обновление балансов(депозит или вывод произошел)

Здесь плюсы заключаются в том, что:

- снимаем нагрузку на контракт
- пользователь теряет меньше всего денег на комиссиях

Но есть критический минус:

- безопасность страдает, нужно будет придумывать ключи и подписи, которые пользователь будет передавать, мы их будем получать и сверять данные, чтобы все было честно
- любой человек, разбирающийся в смартконтракте может отследить транзакции и данные, которые мы передаем, тем самым, прибавив к своим балансам на выходе хоть всю лп, что доступна в пуле
- не юзабилити - для интеграции слишком накрученный вариант
  `
`
  `
`
  `

# Третий вариант:

Данный вариант схож с первым, но имеет сквозной просчет веса каждого пользователя от самого старта пула до его конца жизнедеятельности(ребалансировки.
Механизм пересчета и обновления информации схож, но не имеет деления на сезоны и не зависит от того, когда был произведен реинвест

Тут так же присутствую все плюсы первого варианта:

- Безопасность - извне повлиять на получение прибыли будет сложно, если зайдет кит перед реинвестом, он не сможет забрать все накопления(как реализовано сейчас)
- точные расчеты по каждому юзеру в частности, без нарушения хронологии его действий
- без лишних просчетов и подписей со стороны бэка, тем самым простота в интеграции
- отсутвие минуса, по дорогим транзакциям, ведь пользователь считает основывясь на заработке за весь период, а не по конкретным сезонам, сравниявая, откуда он забрал свою прибыль, а откуда нет(availibleToClaim считается от дельты текущего значения totalFarmed- его последнего значения totalFarmed, обновляя это значение, и пока оно не поменяется, условие подсчета не будет срабатывать)

Логика и математика просчитаны, но тут есть так же минус:

- обязываем пользователей быть активными
- если юзер после реинвеста сделает транзакцию ввода или вывода, его баланс обновится и он будет получать прибыль с учетом заработанных средств с реинвеста
- если юзер сделает позже такую траназкцию(можно кстати инициализировать ее как клейм, отправка 0 value, просто для обновления баланса), то он начнет получать прибыль с обновленного баланса, именно, с того момента, как он обновится, а не с момента реинвеста, тем самым упуская часть прибыли
- и тут двоякая ситуация, хочешь зарабатывать по полной, будь активен, если нет, то да, ты получишь прибыль от доп лп, но не в полном объему
- на дистанцию, со временем они выгребвют то, что им положено(но не больше), но все равно остается процент, который может быть не востребован при закрытии пула, который, по сути, остается в пользовании овнера

Но, учитывая огромные минусы безопасности текущей реализации, этот вариант более разумный на текущий момент, пока не решен вопрос с первыми двумя вариантами

## Сам процесс:

1. Человек выбрал в какой пул инвестировать, указал сумму и нажал кнопку депозит
2. В функции мы записали struct UserInfo, в нем уже записываем amountLP, weight, lastTotalWeight и season
3. Когда человек захочет исполнить транзакцию в определенный пул, сперва сверяем в какой пул он ее отправляет (UserInfo -> poolType)
4. просчитываем срок вложения(время прошедшее от предыдущего изменения глобального стейта, до текщего) dTime = time - lastUpdateTime
5. обновляем общий вес, при условии if (dTime != 0 && totalLP != 0) totalWeight += dTime / totalLP;
6. Далее сделать просчет нового веса юзера на основе изначальных данных, сколько человек вложил и какой вес имеет (чтобы узнать срок инвестирования)
7. Обновляем его баланс
8. сверяем totalFarmed != 0 && UserInfo[id].lastTotalFarmed != totalFarmed и дальше идет условие:
   а: если верное(оно возникнет в том случае, когда во время реинвеста обновится значение заработанных накоплений всеми юзерами):
   - узнаем дельту времени от старта пула до текущего времени
   - просчитываем процент, который полагается юзеру
   - просчитываем сколько полагается юзеру, на основе общего количества накоплений и последнего значения такового в UserInfo availibleToClaim = percent \* (totalFarmed - UserInfo[id].lastTotalFarmed)
   - считаем newAmountLP += availibleToClaim
   - обновляем значение тотал лп totalLP += availibleToClaim
   - Записываем полученные результат в UserInfo
     UserInfo[id] = {
     amountLP: newAmountLP,
     weight,
     lastTotalWeight: totalWeight,
     lastTotalFarmed: totalFarmed,
     lastTotalLP: totalLP
     };
     б: если не совпадает:
   - записываем новую информацию о юзере, которая была прощитана в пунктах 4-6
     UserInfo[id] = {
     amountLP: newAmountLP,
     weight,
     lastTotalWeight: totalWeight,
     lastTotalFarmed: totalFarmed,
     lastTotalLP: totalLP
     }
9. обновляем lastUpdateTime

## Во время реинвеста логика немного легче:

1. фиксируем текущее время time
2. считаем текущий заработок в пуле, делая сам реинвест, получаю значение уже чистой лп, которая прибавилась в пул
3. обновляем reinvestTime = time(текущее время)
4. обновляем totalFarmed += currentFarmed(сквозной просчет)
   `
`
   `
`
   `
`
   `
`
   `
`
   `
`

# Четвертый вариант:

Заключается в том, чтобы немного изменить структуру наших длп токенов и сделать расчет на основании их количество и ребалансировкой при тригере(deposit/withdrawal)

Данная практика имеет свое подтверждения работоспособности и эффективности в ревардных и селфревардных токенах, когда данные shares определяют сколько ревардо необходимо распределить между всеми юзерами и тригером служит любой трансфер токена(то есть любое изменение баланса того или иного кошелька). Есть примеры проектов с огромной аудиторией как на ETH, так и на BSC и на других сетях, где данный механизм работал и работает исправно(во многих и по сей день).
У меня есть репозиторий как и автора данной механики подсчета так и мой личный опыт и кастомизация, на основе его контрактов, под свой проект.

Но тут так же есть свою плюсы и минусы
Из плюсов:

- вновь, безусловно, безопасность, но не настолько точно, как в первом и в третьем вариантах
- точные расчеты
- особенность в том, что всю жизнедеятельность данные только записываются, но фактически из юнисвап не снимаются накопления, их юзер сможет затребовать только в том случае, когда захочет вывести полность, что у него вложено+заработано

Из минусов:

- каждую транзакцию, юзер по сути платит за газ, для мнгновенного распределения долей накопления(в грязном виде, ведь после извлечения накоплений, тратится тот или иной газ на транзакцию и по факту суммы выйдет чуть меньше) всем пользователям
- для подсчета накоплений в каждой транзакции необходимо будет обзванивать юнисвап, что удорожает транзакцию и сделает ее менее безопасной(EVM ботов никто не отменял)

Условия: изначально пул пустой и в нем нет ни одного юзера добыча статики в день примем за константу 100 токенов в день(просто токены к примеру, взято 100 для удобства расчетов по процентам)

## Пример:

1. юзер делает депозит на 200$ и во время депозита проверяется, есть ли данный юзер в массиве, если его нет то он добавляется в первый индекс (массив так скажем замена нфт версии юнисвапа), если есть, то обновляется информация по нему(примерная структура: addressUser, shares, availibleToClaim, maybe amountTokenA & amountTokenB(тут будет зависеть как будут считаться shares))
2. для юзера начислились shares в количестве (тут надо подумать как лучше реализовать, думаю пока что в количестве токена б умноженного на 2 возможно, условно, человек вложил 0.045ETH(по текущему курсу это 100$)+100USDT, вот ему начислилось 200 shares)(как сейчас реализовано они же dlp, только мы их не как токены минтим человеку, а просто храним информацию о количестве данных shares)
3. сформиловалась лп которая начала приносить статику
4. на текущий момент в пуле 200$ которые в день приносят 100 токенов статики. так как юзер всего один, то все 100% идут ему
5. Далее через 1 день зашел новый юзер на 300$
6. смотрим, что в данный момент статики накапало 100 токенов, записываем общие накопления статики для всех юзеров пула на текущий момент, но прежде считаем, если данное значение отлично от нуля, то мы из текущих накоплений (тянем с юнисвапа значение) вычитаем значение, что записано у нас и сохраняем в рамках транзакции в переменную, только потом обновляем общие накопления всех юзеров
7. смотрим на весь массив и обновляем информацию по текущему юзеру, что ему доступно для клейма 100 токенов(как раз таки та самая переменная тут и нужна)
8. Далее проверка второго юзера на экзист из массива, его нет -> добавляем инфу в индекс 2 о его адресе и сколько shares ему начисленно(300 shares) и обновляем информацию о totalSupply shares(их стало 500)
9. еще через 10 дней заходит третий юзер на 500$
10. так же проверка текущих накоплений их уже 1100(100 за первый день и 1000 за 10 дней после)
11. снова считаем, что от прошлого тригера до текущего накопленно 1000 токенов и пробегаемся по массиву, и записывая сколько каждому доступно для клейма статики, первому 100 + 400(так как у него 40% shares) а второму 600(аналогично)
12. добавляем инфу по третьему юзеру

# Описание метода ребалансировки.

В основном, метод ребалансировки собирает вместе все лп токены конкретных пулов, далее свапает их на новые токены, которые необходимы для создания нового пула. При этом количество dlp токенов у юзеров не меняется и после ребалансировки получения новых лп токенов сохраняется в том же процентном соотношении.

### функция rebalancePool относится к основной функции ребалансировки, вызывается только овнером и принимает следующие значения с бэка - структуру перебалансировки CommonDto.RebalanceInfo и общее количество токенов LP, которое будет удалено.

Функция выполняет следующие действия:

1. проверяет, является ли вызывающий функции владельцем контракта, использующим модификатор Seerceiscontractowner из библиотеки Libdiamond
2. сжигает указанное количество токенов LP из пула для удаления, используя функцию commonBurn. Функция возвращает массив, который представляет количество токенов, полученных от сжигания токенов LP.
3. повторяет массив amountGetToken и проверяет, требуется ли обмен токеном для каждого токена.Если требуется обмен, он вызывает функцию swapTokenRebalance контракта ITRANSFER для выполнения обмена токена.
4. вызывает функцию commonMint в новые токены LP для пула Mint, используя параметры Mintpoolinfo и Mintpooltokens.Функция возвращает количество полученных токенов LP (getLP), дополнительные диапазоны для пула Mint (экстраранги) и массив токенов, депонируемых (TokensDeposited), который не используется в этом случае.
5. вызывает функцию rebalanceDLP для восстановления DLPS (делегированные пулы ликвидности)
6. проходит идентификаторы DLP, общее количество удаленных токенов LP (lpRemoveTotal), количество полученных токенов LP (getLP), идентификатор пула с удалением, идентификатор пула Mint и дополнительные диапазоны для mintPoolInfo.

В целом, эта функция перебирает пулы, сжигая токены LP, при необходимости выполняя свапы токенов в нужные, запуская новые токены LP для mint и перебалансировки всех DLP.

### Функция commonBurn - функция используется для удаления ликвидности из определенного пула.Это берет три параметра: poolInfo, removeTokens и totalAmountRemoveLP.

Функция сначала определяет тип пула на основе параметра Boolinfo.Он проверяет имя соответствующего defi и выполняет соответствующую функцию удаления ликвидности на основе типа пула.
Функция возвращает массив, который содержит суммы токенов, полученных после удаления ликвидности из пула.

### Функция commonMint - функция, которая используется для добавления ликвидности к различным типам пулов в системе DEFI.

Функция принимает два параметра: poolInfo, который содержит информацию о пуле и mintTokens, который представляет собой массив токеновых сумм, которые должны быть внесены в pool.

1. сначала проверяет тип используемой платформы DEFI на основе nameid, хранящегося в \_s.Defis.В зависимости от платформы, функция вызывает соответствующую функцию Addliquity из интерфейса IDefifacet.
2. Затем функция возвращает сумму полученных токенов LP (getLP), любую дополнительную информацию о диапазоне (экстраранги) и суммы токенов, депонированных в пул (TokensDeposited).
3. Наконец, функция излучает событие, специфичное для типа используемой платформы DEFI.
4. Если ни одна из поддерживаемых платформ не соответствует nameid, функция возвращается с сообщением об ошибке.

### Функция rebalanceDLP - это частная функция, которая используется для ребалансирования набора DLP (поставщика ликвидности) в системе децентрализованных финансов (DEFI).

Пошаговое описание того, что выполняет функция:
Требуется следующие параметры:
dlpIds: массив идентификаторов DLP, который должен быть перебалансирован.
amountOldLP: общая сумма старых токенов LP, которые ребалансированы.
amountNewLP: общая сумма новых токенов LP, которые заменит старые токены LP.
oldPoolId: идентификатор старого пула, из которого токены LP перебалансируются.
newPoolId: идентификатор нового пула, которому будут перебалансированы токены LP.
newExtraArgs: дополнительные аргументы или данные, которые необходимо обновить для DLP.

1. инициализирует переменную проверку, чтобы отслеживать обработанные токены LP.
2. цикл над каждым идентификатором DLP в массиве dlpIds.
3. Для каждого идентификатора DLP он получает информацию DLP, используя функцию getInfoDLP из контракта DLP.
4. проверяет, соответствует ли poolId DLP параметр oldPoolId
5. рассчитывает новый счет LP для DLP на основе соотношения amountNewLP к amountOldLP.
6. вызывает функцию восстановления из контракта DLP, чтобы обновить DLP с новым идентификатором пула, новым количеством LP и новыми дополнительными аргументами.
7. добавляет количество LP текущего DLP к переменной checkTotalLP.
8. после итерации по всем DLPS он проверяет, будет ли checkTotAllp равен сумме старых LP

Таким образом, функция rebalanceDLP отвечает за перебалансирование набора DLP за счет обновления их идентификатора пула, подсчета LP и дополнительных аргументов.Эта функция гарантирует, что общее количество LP остается последовательным до и после процесса перебалансировки.

### Были рассмотренны несколько моделей реинвестирования, о каждой опишу кратко плюсы и минусы:

1. Честный при реинвесте каждую транзакцию(только статистические цифры, на практике, за счет комиссий доходность куда ниже)
   Данный метод больше рассчитывался для сравнения к нему, как к эталонным цифрам, реализовывать его бессмысленно.
2. Справедливый расчет веса юзера и автораспределение во время реинвеста.
   Эта модель более актуальна к реальным условиям и самый безопасный и можно считать честный.
   Из плюсов безусловно это:

- безопасность
- честный просчет(относительно того, что все юзеры будут в одинаковых условиях, ведь их балансы обновятся в момент реинвестирования)
- нет высокой нагрузки на транзакции пользователей
  К минусам стоит отнести:
- дорогая транзакция реинвестирования для дева(но это удорожание можно вкладывать в комиссии сервиса), данная модель предполагает в момент реинвеста пробежаться по массиву всех юзеров, просчитать их окончательный вес на момент реинвеста и обновить балансы каждого юзера

3. Реинвестирование всем каждые, условно, 200$ и при этом считать вес юзеров
   Из плюсов:

- безопасность
- также относительная честность
  Из минусов:
- повышается нагрузка на транзакции юзеров, но она будет распределенной, то есть, если накопилось 200$, вызывается реинвест,
  далее так же начинаются просчеты, но вот распределение в цикле идет не сразу для всех юзеров, а по переменной gasUsed,
  то есть мы можем установить лимит используемого газа методом, как лимит, условно, в 300_000 будет израсходован, метод
  фиксирует текущие значения и продолжает транзакцию дальше, следующий пользователь, что инициализирует транзу, продолжит распределять остальным
- отсюда второй минус, что люди будут получать обновления балансов только в тот момент, когда кто-либо делает транзакции, то есть, пока нет актива - нет авто начислений

4. Реинвестирование всем каждые, условно, 200$ и при этом не считать вес юзеров, чтобы снизить нагрузку на метод
   Из плюсов, очень сложно сказать, единственное, наверное:

- реинвестирование будет происходить в автоматическом режиме
- нагрузка на транзакцию чуть меньше, ведь не будет считаться вес юзеров
  К минусам можно отнести все минусы 3 модели, плюс так же дыра по безопасности, но с наименее значимым весом, относительно текущей реализации

5. При реинвесте каждые, условно, 200$ и пересчете стоимости ДЛП
   Данная модель базируется на текущей реализации, но с пересчетом стоимости ДЛП.
   То есть каждую транзакцию рассчитывается k=totalDLP/totalLP и в новой транзакции будет начислять меньшее количество DLP
   Здесь будет несколько триггеров для данной транзакции, это как минимум сумма накоплений, сумма входа(условно система antiwhale),
   сумма удерживаемых средств(чтобы за транзакцию платили только те, у кого финансов вложено больше определенного значения)
   Да данные триггеры так же применимы и к 3, и к 4 моделям
   Из плюсов:

- минимальная нагрузка на транзакции юзеров, ведь реинвестирование и расчет коэффициента будет происходить только при определенных условиях
- безопасность на уровне 3 и 4 моделей
- относительная честность расчетов
- нет так таковых начислений, просто доля от общего пула будет всегда пересчитываться для всех,
  К минусам:
- равноправие в пуле как и сейчас, что неважно сколько ты держал, получишь в соответствии с процентным содержанием на момент реинвеста
  но этот минус так же можно отнести и к 4 модели, но он значимо ниже, чем реализуется сейчас

Если подвести черту, то у каждой из моделей есть свои плюсы и минусы.
Если основываться на простоте вычислений. меньших нагрузках и относительно нормальной безопасности, то можно выбрать 5 модель
Если считать максимально безопасно и относительно честно, то подходит 2 модель
3 и 4 модель уходят совсем на задний план и особо не предлагаются для реализации

gasUsed in depositTokens 800_000 - 1_200_000
gasUsed in removeTokens 100_000 - 500_000
gasUsed in reinvest
