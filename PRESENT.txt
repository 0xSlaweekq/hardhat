Во время депозита необходимо общую и по каждому юзеру мапить информацию, например, как я вижу структуру:
totalLP - общее количество лп
totalWeight - общий вес

started - булевая начала действия пула

ReinvestInfo 
    season: текущий сезон
    startTime: время начала сезона
    reinvestTime: время, когда произлшел реинвест(при переходе на новый сезон, тут ставится, а для нового это уже будет startTime)
    startTotalWeight: начальное значение веса в сезоне
    endTotalWeight: конечный вес(по аналогии с reinvestTime)
    totalFarmed: общий заработок за все реинвесты(суммируется)
    totalLP: общее лп на момент закрытия сезона

season - какой текущий сезон
reinvestTime - время реинвестирования
lastUpdateTime - последнее время обновления данных(обновляется каждую транзакцию)
currentFarmed сколько сейчас заработано(конкретно в текущем сезоне)


UserInfo - информация по юзеру
    amountLP: сколько вложено юзером
    weight: вес юзера
    lastTotalWeight: последний общий вес
    season: последний сезон, в каком юзер делал какую-либо транзакцию


Сам процесс:
1) Человек выбрал в какой пул инвестировать, указал сумму и нажал кнопку депозит
2) В функции мы записали struct UserInfo, в нем уже записываем amountLP, weight, lastTotalWeight и season
3) Когда человек захочет исполнить транзакцию в определенный пул, сперва сверяем в какой пул он ее отправляет (UserInfo -> poolType)
4) Обновляем его баланс
5) Далее сделать просчет новго веса на основе изначальных данных, сколько человек вложил и какой вес имеет (чтобы узнать срок инвестирования)
6) далее сверяем сезон юзера с текущим сезоном и дальше идет условие:
  а: если сезон совпадает:
    - Обновляем общий вес и лп
    - Записываем полученные результат в UserInfo
    - обновляем lastUpdateTime
  б: если сезон не совпадает:
    - обращаемся к массиву данных по каждому из сезонов в цикле, начиная с UserInfo[id].season до ReinvestInfo.length, но при этом появляется новое условие
    а: если i+1 не равен текущему сезону:
      - считаем дельту времени, что он пробыл в пуле с момента его последней транзакции до момента закрытия сезона(реинвеста)
      - просчитываем процент его доли
      - просчитываем, сколько доступно для клейма из доходной лп
      - просчитываем вес юзера в последнем сезоне, в котором он участвовал + фиксируем новый lastTotalWeight (обновление каждый пройденный цикл для конкретного сезона)
      - записываем новую информацию о юзере, прибавляя к его amountLP заработанные средства
      - повтор, и так до тех пор, пока цикл не пройдет по всей длине массива ReinvestInfo, как только i+1 станет равным текущему сезону, идем по else
    б: i+1 равен текущему сезону
      - считаем текущий вес пользователя(все его предыдущие веса и вложения уже пересчитаны и просуммированы как надо)
      - определяем, делает человек депозит или вывод и обновляем на основе этих данных UserInfo(прибавляем текущий value или вычитаем из его amountLP)
7) обновляем lastUpdateTime 

Во время реинвеста логика примерна такая:
1) фиксируем текущее время
2) делаем сам реинвест, получаю значение уже чистой лп, которая прибавилась в пул
3) считаем текущий заработок в пуле
4) обновляем информацию в текущем пуле ReinvestInfo, а именно:
  ReinvestInfo[season] = {
    season: season(текущий сезон),
    startTime: reinvestTime(это время прошлого реинвеста),
    reinvestTime: time(текущее время),
    startTotalWeight: ReinvestInfo[season].startTotalWeightЖReinvestInfo(не трогаем, это значение уже инициализировано),
    endTotalWeight: totalWeight(текущий вес),
    totalFarmed: currentFarmed(сколько заработанно конкретно в этом сезоне),
    totalLP: totalLP(обновляем сколько лп на момент реинвеста)
  };
5) обновляем reinvestTime = time(текущее время)
6) обновляем сезон season++ startTotalWeight = totalWeight(это значение будет использоваться для установки в новый сезон)
7) инициализируем данные для нового сезона:
    ReinvestInfo[season] = {
    season: season,
    startTime: reinvestTime(это время уже текущего реинвеста),
    reinvestTime: 0,
    startTotalWeight: totalWeight(это значение используется для установки начального в новом сезоне),
    endTotalWeight: 0,
    totalFarmed: 0,
    totalLP: 0
  };

Плюсы данной реализации:
  - Безопасность - извне повлиять на получение прибыли будет сложно, если зайдет кит перед реинвестом, он не сможет забрать все накопления(как реализовано сейчас)
  - точные расчеты по каждому юзеру в частности, без нарушения хронологии его действий
  - без лишних просчетов и подписей со стороны бэка, тем самым простота в интеграции
Точные цифры математики и формулы еще нужно немного докрутить, но тут есть сразу пару нюансов:
  - если юзер на протяжении, к примеру, 100 или 1000 сезонов, а того и более(вложил деньги на пару лет) не будет предпринимать никаких действий в пуле, 




UPD:
Четвертая идея заключается в том, чтобы немного изменить структуру наших длп токенов и сделать расчет на основании их количество и ребалансировкой при тригере(deposit/withdrawal)

Условия: изначально пул пустой и в нем нет ни одного юзера добыча статики в день примем за константу 100 токенов в день(просто токены к примеру, взято 100 для удобства расчетов по процентам)

Пример:
юзер делает депозит на 200$ и во время депозита проверяется, есть ли данный юзер в массиве, если его нет то он добавляется в первый индекс (массив так скажем замена нфт версии юнисвапа), если есть, то обновляется информация по нему(примерная структура: addressUser, shares, availableStaticToClaim, maybe amountTokenA & amountTokenB(тут будет зависеть как будут считаться shares))
для юзера начислились shares в количестве (тут надо подумать как лучше реализовать, думаю пока что в количестве токена б умноженного на 2 возможно, условно, человек вложил 0.045ETH(по текущему курсу это 100$)+100USDT, вот ему начислилось 200 shares)(как сейчас реализовано они же dlp, только мы их не как токены минтим человеку, а просто храним информацию о количестве данных shares)
сформиловалась лп которая начала приносить статику
на текущий момент в пуле 200$ которые в день приносят 100 токенов статики. так как юзер всего один, то все 100% идут ему
Далее через 1 день зашел новый юзер на 300$
смотрим, что в данный момент статики накапало 100 токенов, записываем общие накопления статики для всех юзеров пула на текущий момент, но прежде считаем, если данное значение отлично от нуля, то мы из текущих накоплений (тянем с юнисвапа значение) вычитаем значение, что записано у нас и сохраняем в рамках транзакции в переменную, только потом обновляем общие накопления всех юзеров
смотрим на весь массив и обновляем информацию по текущему юзеру, что ему доступно для клейма 100 токенов(как раз таки та самая переменная тут и нужна)
Далее проверка второго юзера на экзист из массива, его нет -> добавляем инфу в индекс 2 о его адресе и сколько shares ему начисленно(300 shares) и обновляем информацию о totalSupply shares(их стало 500)
еще через 10 дней заходит третий юзер на 500$
так же проверка текущих накоплений их уже 1100(100 за первый день и 1000 за 10 дней после)
снова считаем, что от прошлого тригера до текущего накопленно 1000 токенов и пробегаемся по массиву, и записывая сколько каждому доступно для клейма статики, первому 100 + 400(так как у него 40% shares) а второму 600(аналогично)
добавляем инфу по третьему юзеру

Данная практика имеет свое подтверждения работоспособности и эффективности в ревардных и селфревардных токенах, когда данные shares определяют сколько ревардо необходимо распределить между всеми юзерами и тригером служит любой трансфер токена(то есть любое изменение баланса того или иного кошелька). Есть примеры проектов с огромной аудиторией как на ETH, так и на BSC и на других сетях, где данный механизм работает и работает исправно(во многих и по сей день). 
У меня есть репозиторий как и автора данной механики подсчета так и мой личный опыт и кастомизация, на основе его контрактов, под свой проект.










startTime - время запуска пула(timestamp)
totalFarmed общий заработок за все реинвесты(суммируется)

UserInfo - информация по юзеру
    amountLP: сколько вложено юзером
    weight: вес юзера
    lastTotalWeight: последний общий вес
    lastTotalFarmed: последний общий заработок
    lastTotalLP: последнее общее количество лп токенов