Во время депозита необходимо по каждому юзеру мапить информацию, например, как я вижу структуру:
poolType – выбранный пул, юник 2 или 3, суши, компад и тд
initialTime (block.timestamp) - он будет запоминать точку входа
depositAmount – сколько dlp(lp) было получено после депозита
withdrawalAmount – здесь будет записываться, сколько доступно вознаграждений для клейма
withdrawedAmount – сколько всего вознаграждений получено
dedline – дата разрешения снятия наград или реинвестирования
Сам процесс:
1)     Человек выбрал в какой пул инвестировать, указал сумму и нажал кнопку депозит
2)     В функции мы записали выбранный пул в poolType, в struct UserInfo, в нем уже записываем depositAmount и initialTime (так же можно указать и срок инвестирования (deadline), об этом напишу чуть позже)
3)     Когда человек захочет добавить депозит в определенный пул, сперва сверяем в какой пул он добавляет (UserInfo -> poolType)
4)     Далее сделать просчет вознаграждения, на основе изначальных данных, сколько человек вложил и когда (чтобы узнать срок инвестирования)
5)     Записываем полученный результат в withdrawalAmount
6)     initialTime обновляем, depositAmount прибавляем.
7)     Если человек захочет реинвестировать, то сперва так же будем считать прибыль, начислим ее и обнулим в юзер инфо, к его депу добавим прибыль
8)     Если человек захочет забрать все и перейти в другой пул, ситуация примерно такая же, информацию о прошлом пуле обнуляем, новый заполняем
На счет дедлайна, можно установить им сроки вложения, условно на неделю, две, месяц или вообще произвольную (выбор на фронте в календаре, для удобства). И тогда при депозите будет вноситься дата дедлайна в таймстемп, до этого момента человек не сможет забрать или реинвестировать


UPD:
Четвертая идея заключается в том, чтобы немного изменить структуру наших длп токенов и сделать расчет на основании их количество и ребалансировкой при тригере(deposit/withdrawal)

Условия: изначально пул пустой и в нем нет ни одного юзера добыча статики в день примем за константу 100 токенов в день(просто токены к примеру, взято 100 для удобства расчетов по процентам)

Пример:
юзер делает депозит на 200$ и во время депозита проверяется, есть ли данный юзер в массиве, если его нет то он добавляется в первый индекс (массив так скажем замена нфт версии юнисвапа), если есть, то обновляется информация по нему(примерная структура: addressUser, shares, availableStaticToClaim, maybe amountTokenA & amountTokenB(тут будет зависеть как будут считаться shares))
для юзера начислились shares в количестве (тут надо подумать как лучше реализовать, думаю пока что в количестве токена б умноженного на 2 возможно, условно, человек вложил 0.045ETH(по текущему курсу это 100$)+100USDT, вот ему начислилось 200 shares)(как сейчас реализовано они же dlp, только мы их не как токены минтим человеку, а просто храним информацию о количестве данных shares)
сформиловалась лп которая начала приносить статику
на текущий момент в пуле 200$ которые в день приносят 100 токенов статики. так как юзер всего один, то все 100% идут ему
Далее через 1 день зашел новый юзер на 300$
смотрим, что в данный момент статики накапало 100 токенов, записываем общие накопления статики для всех юзеров пула на текущий момент, но прежде считаем, если данное значение отлично от нуля, то мы из текущих накоплений (тянем с юнисвапа значение) вычитаем значение, что записано у нас и сохраняем в рамках транзакции в переменную, только потом обновляем общие накопления всех юзеров
смотрим на весь массив и обновляем информацию по текущему юзеру, что ему доступно для клейма 100 токенов(как раз таки та самая переменная тут и нужна)
Далее проверка второго юзера на экзист из массива, его нет -> добавляем инфу в индекс 2 о его адресе и сколько shares ему начисленно(300 shares) и обновляем информацию о totalSupply shares(их стало 500)
еще через 10 дней заходит третий юзер на 500$
так же проверка текущих накоплений их уже 1100(100 за первый день и 1000 за 10 дней после)
снова считаем, что от прошлого тригера до текущего накопленно 1000 токенов и пробегаемся по массиву, и записывая сколько каждому доступно для клейма статики, первому 100 + 400(так как у него 40% shares) а второму 600(аналогично)
добавляем инфу по третьему юзеру

Данная практика имеет свое подтверждения работоспособности и эффективности в ревардных и селфревардных токенах, когда данные shares определяют сколько ревардо необходимо распределить между всеми юзерами и тригером служит любой трансфер токена(то есть любое изменение баланса того или иного кошелька). Есть примеры проектов с огромной аудиторией как на ETH, так и на BSC и на других сетях, где данный механизм работает и работает исправно(во многих и по сей день). 
У меня есть репозиторий как и автора данной механики подсчета так и мой личный опыт и кастомизация, на основе его контрактов, под свой проект.
