Первый вариант:

Во время депозита необходимо общую и по каждому юзеру мапить информацию, например, как я вижу структуру:
totalLP - общее количество лп
totalWeight - общий вес

started - булевая начала действия пула

ReinvestInfo 
    season: текущий сезон
    startTime: время начала сезона
    reinvestTime: время, когда произлшел реинвест(при переходе на новый сезон, тут ставится, а для нового это уже будет startTime)
    startTotalWeight: начальное значение веса в сезоне
    endTotalWeight: конечный вес(по аналогии с reinvestTime)
    totalFarmed: общий заработок за все реинвесты(суммируется)
    totalLP: общее лп на момент закрытия сезона

season - какой текущий сезон
reinvestTime - время реинвестирования
lastUpdateTime - последнее время обновления данных(обновляется каждую транзакцию)
currentFarmed сколько сейчас заработано(конкретно в текущем сезоне)


UserInfo - информация по юзеру
    amountLP: сколько вложено юзером
    weight: вес юзера
    lastTotalWeight: последний общий вес
    season: последний сезон, в каком юзер делал какую-либо транзакцию


Сам процесс:
1) Человек выбрал в какой пул инвестировать, указал сумму и нажал кнопку депозит
2) В функции мы записали struct UserInfo, в нем уже записываем amountLP, weight, lastTotalWeight и season
3) Когда человек захочет исполнить транзакцию в определенный пул, сперва сверяем в какой пул он ее отправляет (UserInfo -> poolType)
4) просчитываем срок вложения(время прошедшее от предыдущего изменения глобального стейта, до текщего)  dTime = time - lastUpdateTime
5) обновляем общий вес, при условии if (dTime != 0 && totalLP != 0) totalWeight += dTime / totalLP;
6) Далее сделать просчет нового веса юзера на основе изначальных данных, сколько человек вложил и какой вес имеет (чтобы узнать срок инвестирования)
7) Обновляем его баланс и totalLP 
  let newAmountLP = UserInfo[id].amountLP;
  if (type == 'deposit') {
    newAmountLP += amountLP;
    totalLP += amountLP;
  }
  if (type == 'withdraw') {
    newAmountLP -= amountLP;
    totalLP -= amountLP;
  }
8) далее сверяем сезон юзера с текущим сезоном и дальше идет условие:
  а: если сезон совпадает:
    - Обновляем общий вес и лп
    - Записываем полученные результат в UserInfo
      UserInfo[id] = {
        amountLP: newAmountLP,
        weight,
        lastTotalWeight: totalWeight,
        season
      }
  б: если сезон не совпадает:
    - обращаемся к массиву данных по каждому из сезонов в цикле, начиная с UserInfo[id].season до ReinvestInfo.length, но при этом появляется новое условие poolInfo = ReinvestInfo[i]
    а: если i+1 не равен текущему сезону:
      - считаем вес сезона
      - считаем дельту времени, что он пробыл в пуле с момента его последней транзакции до момента закрытия сезона(реинвеста) 
      dTimeSeason = poolInfo.reinvestTime - poolInfo.startTime
      - просчитываем процент его доли percent = weightSeason / dTimeSeason;
      - просчитываем, сколько доступно для клейма из доходной лп availibleToClaim = percent * poolInfo.totalFarmed;
      - просчитываем вес юзера в последнем сезоне, в котором он участвовал + фиксируем новый lastTotalWeight (обновление каждый пройденный цикл для конкретного сезона)
      - записываем новую информацию о юзере, прибавляя к его amountLP заработанные средства
        UserInfo[id] = {
          amountLP: UserInfo[id].amountLP + availibleToClaim,
          weight: weightSeason,
          lastTotalWeight: poolInfo.endTotalWeight,
          season
        }
      - обновляем значение тотал лп totalLP += availibleToClaim;
      - повтор, и так до тех пор, пока цикл не пройдет по всей длине массива ReinvestInfo, как только i+1 станет равным текущему сезону, идем по else
    б: i+1 равен текущему сезону
      - считаем текущий вес пользователя(все его предыдущие веса и вложения уже пересчитаны и просуммированы как надо)
      - определяем, делает человек депозит или вывод и обновляем на основе этих данных UserInfo(прибавляем текущий value или вычитаем из его amountLP)4
      - Записываем полученные результат в UserInfo
        if (type == 'deposit') {
          UserInfo[id] = {
            amountLP: UserInfo[id].amountLP + amountLP,
            weight: currentWeight,
            lastTotalWeight: totalWeight,
            season
          };
        }
        if (type == 'withdraw') {
          UserInfo[id] = {
            amountLP: UserInfo[id].amountLP - amountLP,
            weight: currentWeight,
            lastTotalWeight: totalWeight,
            season
          };
        }
9) обновляем lastUpdateTime 

Во время реинвеста логика примерна такая:
1) фиксируем текущее время time
2) считаем текущий заработок в пуле, делая сам реинвест, получаю значение уже чистой лп, которая прибавилась в пул currentFarmed
3) обновляем totalFarmed += currentFarmed(сквозной просчет)
4) обновляем информацию в текущем пуле ReinvestInfo, а именно:
  ReinvestInfo[season] = {
    season: season(текущий сезон),
    startTime: reinvestTime(это время прошлого реинвеста),
    reinvestTime: time(текущее время),
    startTotalWeight: ReinvestInfo[season].startTotalWeightЖReinvestInfo(не трогаем, это значение уже инициализировано),
    endTotalWeight: totalWeight(текущий вес),
    totalFarmed: currentFarmed(сколько заработанно конкретно в этом сезоне),
    totalLP: totalLP(обновляем сколько лп на момент реинвеста)
  };
5) обновляем reinvestTime = time(текущее время)
6) обновляем сезон season++ startTotalWeight = totalWeight(это значение будет использоваться для установки в новый сезон)
7) инициализируем данные для нового сезона:
    ReinvestInfo[season] = {
    season: season,
    startTime: reinvestTime(это время уже текущего реинвеста),
    reinvestTime: 0,
    startTotalWeight: totalWeight(это значение используется для установки начального в новом сезоне),
    endTotalWeight: 0,
    totalFarmed: 0,
    totalLP: 0
  };

Плюсы данной реализации:
  - Безопасность - извне повлиять на получение прибыли будет сложно, если зайдет кит перед реинвестом, он не сможет забрать все накопления(как реализовано сейчас)
  - точные расчеты по каждому юзеру в частности, без нарушения хронологии его действий
  - без лишних просчетов и подписей со стороны бэка, тем самым простота в интеграции

Точные цифры математики и формулы еще нужно немного докрутить, но тут есть сразу пару нюансов:
  - если юзер на протяжении, к примеру, 100 или 1000 сезонов, а того и более(вложил деньги на пару лет) не будет предпринимать никаких действий в пуле, то после этого, при первой его транзакции, сперва нужно будет просчитать все его балансы за каждый из сезонов, что может быть слишком дорого для юзера в таком случае(но по завершении аналитики и формул для расчета, можно будет смодулировать такую транзакцию искусственно, чтобы видеть примерные значения затраченного газа) или вовсе транзакция будет ревертиться по газвару, тогда ее нужно будет делить по определенному количеству сезонов, но снова же, сколько транзакций это будет и какая их стоимость остается открытым вопросом


Второй вариант:

логику первого варианта частично развернуть на бэке
- В контракте оставить маппы и структуры по записыванию информации как общей, так и отдельного юзера
- но в момент, когда сезоны не будут совпадать, ретернить транзакцию со всеми необходимыми данными на бэк
- если бэк будет будет получать не успешное выполнение транзакции, а массив данных, то он начнет просчет на основе полученных данных
- затем, оценит стоимость транзакции обновления баланса юзера и общего стейта
- вычесть данную комиссию +10%(от самой комиссии) от уже полного amountLP юзера
- и отправить транзакцию на обновление балансов(депозит или вывод произошел)

Здесь плюсы заключаются в том, что:
- снимаем нагрузку на контракт
- пользователь теряет меньше всего денег на комиссиях

Но есть критический минус:
- безопасность страдает, нужно будет придумывать ключи и подписи, которые пользователь будет передавать, мы их будем получать и сверять данные, чтобы все было честно 
- любой человек, разбирающийся в смартконтракте может отследить транзакции и данные, которые мы передаем, тем самым, прибавив к своим балансам на выходе хоть всю лп, что доступна в пуле
- не юзабилити - для интеграции слишком накрученный вариант


Третий вариант:

Данный вариант схож с первым, но имеет сквозной просчет веса каждого пользователя от самого старта пула до его конца жизнидеятельности(ребалансировки)
Механизм просчета и обновления информации схож, но не имеет деления на сезоны и не зависит от того, когда был произведен реинвест

Сам процесс:
1) Человек выбрал в какой пул инвестировать, указал сумму и нажал кнопку депозит
2) В функции мы записали struct UserInfo, в нем уже записываем amountLP, weight, lastTotalWeight и season
3) Когда человек захочет исполнить транзакцию в определенный пул, сперва сверяем в какой пул он ее отправляет (UserInfo -> poolType)
4) просчитываем срок вложения(время прошедшее от предыдущего изменения глобального стейта, до текщего)  dTime = time - lastUpdateTime
5) обновляем общий вес, при условии if (dTime != 0 && totalLP != 0) totalWeight += dTime / totalLP;
6) Далее сделать просчет нового веса юзера на основе изначальных данных, сколько человек вложил и какой вес имеет (чтобы узнать срок инвестирования)
7) Обновляем его баланс
8) сверяем totalFarmed != 0 && UserInfo[id].lastTotalFarmed != totalFarmed и дальше идет условие:
  а: если верное(оно возникнет в том случае, когда во время реинвеста обновится значение заработанных накоплений всеми юзерами):
    - узнаем дельту времени от старта пула до текущего времени
    - просчитываем процент, который полагается юзеру
    - просчитываем сколько полагается юзеру, на основе общего количества накоплений и последнего значения такового в UserInfo availibleToClaim = percent * (totalFarmed - UserInfo[id].lastTotalFarmed)
    - считаем newAmountLP += availibleToClaim
    - обновляем значение тотал лп totalLP += availibleToClaim
    - Записываем полученные результат в UserInfo
    UserInfo[id] = {
      amountLP: newAmountLP,
      weight,
      lastTotalWeight: totalWeight,
      lastTotalFarmed: totalFarmed,
      lastTotalLP: totalLP
    };
  б: если не совпадает:
    - записываем новую информацию о юзере, которая была прощитана в пунктах 4-6
    UserInfo[id] = {
      amountLP: newAmountLP,
      weight,
      lastTotalWeight: totalWeight,
      lastTotalFarmed: totalFarmed,
      lastTotalLP: totalLP
    }
9) обновляем lastUpdateTime 

Во время реинвеста логика немного легче:
1) фиксируем текущее время time
2) считаем текущий заработок в пуле, делая сам реинвест, получаю значение уже чистой лп, которая прибавилась в пул
3) обновляем reinvestTime = time(текущее время)
4) обновляем totalFarmed += currentFarmed(сквозной просчет)


Тут так же присутствую все плюсы первого варианта:
  - Безопасность - извне повлиять на получение прибыли будет сложно, если зайдет кит перед реинвестом, он не сможет забрать все накопления(как реализовано сейчас)
  - точные расчеты по каждому юзеру в частности, без нарушения хронологии его действий
  - без лишних просчетов и подписей со стороны бэка, тем самым простота в интеграции
  - отсутвие минуса, по дорогим транзакциям, ведь пользователь считает основывясь на заработке за весь период, а не по конкретным сезонам, сравниявая, откуда он забрал свою прибыль, а откуда нет(availibleToClaim считается от дельты текущего значения totalFarmed- его последнего значения totalFarmed, обновляя это значение, и пока оно не поменяется, условие подсчета не будет срабатывать)

Логика и математика просчитаны, но тут есть так же минус:
  - обязываем пользователей быть активными
  - если юзер после реинвеста сделает транзакцию ввода или вывода, его баланс обновится и он будет получать прибыль с учетом заработанных средств с реинвеста
  - если юзер сделает позже такую траназкцию(можно кстати инициализировать ее как клейм, отправка 0 value, просто для обновления баланса), то он начнет получать прибыль с обновленного баланса, именно, с того момента, как он обновится, а не с момента реинвеста, тем самым упуская часть прибыли
  - и тут двоякая ситуация, хочешь зарабатывать по полной, будь активен, если нет, то да, ты получишь прибыль от доп лп, но не в полном объему
  - на дистанцию, со временем они выгребвют то, что им положено(но не больше), но все равно остается процент, который может быть не востребован при закрытии пула, который, по сути, остается в пользовании овнера

Но, учитывая огромные минусы безопасности текущей реализации, этот вариант более разумный на текущий момент, пока не решен вопрос с первыми двумя вариантами

Четвертый вариант:
З
аключается в том, чтобы немного изменить структуру наших длп токенов и сделать расчет на основании их количество и ребалансировкой при тригере(deposit/withdrawal)

Условия: изначально пул пустой и в нем нет ни одного юзера добыча статики в день примем за константу 100 токенов в день(просто токены к примеру, взято 100 для удобства расчетов по процентам)

Пример:
1) юзер делает депозит на 200$ и во время депозита проверяется, есть ли данный юзер в массиве, если его нет то он добавляется в первый индекс (массив так скажем замена нфт версии юнисвапа), если есть, то обновляется информация по нему(примерная структура: addressUser, shares, availibleToClaim, maybe amountTokenA & amountTokenB(тут будет зависеть как будут считаться shares))
2) для юзера начислились shares в количестве (тут надо подумать как лучше реализовать, думаю пока что в количестве токена б умноженного на 2 возможно, условно, человек вложил 0.045ETH(по текущему курсу это 100$)+100USDT, вот ему начислилось 200 shares)(как сейчас реализовано они же dlp, только мы их не как токены минтим человеку, а просто храним информацию о количестве данных shares)
3) сформиловалась лп которая начала приносить статику
4) на текущий момент в пуле 200$ которые в день приносят 100 токенов статики. так как юзер всего один, то все 100% идут ему
5) Далее через 1 день зашел новый юзер на 300$
6) смотрим, что в данный момент статики накапало 100 токенов, записываем общие накопления статики для всех юзеров пула на текущий момент, но прежде считаем, если данное значение отлично от нуля, то мы из текущих накоплений (тянем с юнисвапа значение) вычитаем значение, что записано у нас и сохраняем в рамках транзакции в переменную, только потом обновляем общие накопления всех юзеров
7) смотрим на весь массив и обновляем информацию по текущему юзеру, что ему доступно для клейма 100 токенов(как раз таки та самая переменная тут и нужна)
8) Далее проверка второго юзера на экзист из массива, его нет -> добавляем инфу в индекс 2 о его адресе и сколько shares ему начисленно(300 shares) и обновляем информацию о totalSupply shares(их стало 500)
9) еще через 10 дней заходит третий юзер на 500$
10) так же проверка текущих накоплений их уже 1100(100 за первый день и 1000 за 10 дней после)
11) снова считаем, что от прошлого тригера до текущего накопленно 1000 токенов и пробегаемся по массиву, и записывая сколько каждому доступно для клейма статики, первому 100 + 400(так как у него 40% shares) а второму 600(аналогично)
12) добавляем инфу по третьему юзеру

Данная практика имеет свое подтверждения работоспособности и эффективности в ревардных и селфревардных токенах, когда данные shares определяют сколько ревардо необходимо распределить между всеми юзерами и тригером служит любой трансфер токена(то есть любое изменение баланса того или иного кошелька). Есть примеры проектов с огромной аудиторией как на ETH, так и на BSC и на других сетях, где данный механизм работал и работает исправно(во многих и по сей день). 
У меня есть репозиторий как и автора данной механики подсчета так и мой личный опыт и кастомизация, на основе его контрактов, под свой проект.

Но тут так же есть свою плюсы и минусы
Из плюсов:
  - вновь, безусловно, безопасность, но не настолько точно, как в первом и в третьем вариантах
  - точные расчеты
  - особенность в том, что всю жизнедеятельность данные только записываются, но фактически из юнисвап не снимаются накопления, их юзер сможет затребовать только в том случае, когда захочет вывести полность, что у него вложено+заработано

Из минусов:
  - каждую транзакцию, юзер по сути платит за газ, для мнгновенного распределения долей накопления(в грязном виде, ведь после извлечения накоплений, тратится тот или иной газ на транзакцию и по факту суммы выйдет чуть меньше) всем пользователям
  - для подсчета накоплений в каждой транзакции необходимо будет обзванивать юнисвап, что удорожает транзакцию и сделает ее менее безопасной(EVM ботов никто не отменял)
